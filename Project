TITLE MASM Template    					(Project.asm)

INCLUDE Irvine32.inc

main EQU start@0

HitByMeteor proto, temp_coord:coord

CopyCoordFrom proto, temp1 : coord, temp2 : coord

; Border

TopBorder = 1
BottomBorder = 30
LeftBorder = 1
RightBorder = 63

;Earth Ranger
EarthRanger struct
    body1  byte "  ______           _   _       _____                             "
    body2  byte " |  ____|         | | | |     |  __ \                            "
    body3  byte " | |__   __ _ _ __| |_| |__   | |__) |__ _ _ __   __ _  ___ _ __ "
    body4  byte " |  __| / _` | '__| __| '_ \  |  _  // _` | '_ \ / _` |/ _ \ '__|"
    body5  byte " | |___| (_| | |  | |_| | | | | | \ \ (_| | | | | (_| |  __/ |   "
    body6  byte " |_____|\__,_|_|   \__|_| |_| |_|  \_\__,_|_| |_|\__, |\___|_|   "
    body7  byte "                                                 |___/           "
    body8  byte "  _____                      ___    _              _             _   "
    body9  byte " |  __ \                    / _ \  | |            | |           | |  "
    body10 byte " | |__) | __ ___  ___ ___  | | | | | |_ ___    ___| |_ __ _ _ __| |_ "
    body11 byte " |  ___/ '__/ _ \/ __/ __| | | | | | __/ _ \  / __| __/ _` | '__| __|"
    body12 byte " | |   | | |  __/\__ \__ \ | |_| | | || (_) | \__ \ || (_| | |  | |_ "
    body13 byte " |_|   |_|  \___||___/___/  \___/   \__\___/  |___/\__\__,_|_|   \__|"
    XY coord<22,5>

    attribute1 word 69 DUP(1)
    attribute2 word 69 DUP(9)
    attribute3 word 69 DUP(15)
    attribute4 word 69 DUP(10)
    attribute5 word 69 DUP(2)
    attribute6 word 69 DUP(14)
EarthRanger ends

; Explosion
ExplosionAnimation struct
    body1 byte "*"
    body2 byte "***"
    body3 byte "* *"
    body4 byte "*   *"
    mode byte 0
    XY coord <0,0>
ExplosionAnimation ends

; Background

; Background Plane

BackgroundPlane struct
    body0   byte    "                   _|_                   "
    body1   byte    "                  /   \                  "
    body2   byte    "               __/ (_) \__               "
    body3   byte    "          ____/_ ======= _\____          "
    body4   byte    " ________/ _/ (_)_______(_) \_ \________ "
    body5   byte    "<________     | /   _   \ |     ________>"
    body6   byte    "  O O O  \___  |   (_)   |  ___/  O O O  "
    body7   byte    "             \__\_______/__/             "
    PlaneLength dword LENGTHOF BackgroundPlane.body1
BackgroundPlane ends

; Background Border

BackgroundBorder struct
    body1 byte "________________________________________________________"
    body2 byte "|                                                      |"
    body3 byte "|______________________________________________________|"
    XY coord<64,0>
BackgroundBorder ends

; Earth

Earth struct

    body1  byte    "           ******************************************           "
    body2  byte    "       **************~~~~~~~~~~~****~~~~~~***************       "
    body3  byte    "    ******************~~~~~~~~~~~***~~~~~~~~~***************    "
    body4  byte    "  **************~~~****~~~~~~~~~~~~~~~~~~~~~~~~***************  "
    body5  byte    "**~~~~******~~~~~~~~~***~~~~~~~~~~~~~~~~~~~~~~~~~***********~~**"
    ;Earth Color
    attribute1 word 20 DUP(2), 12 DUP(1), 5 DUP(0Fh), 5 DUP(1), 22 DUP(2)
    attribute2 word 21 DUP(2), 11 DUP(1), 4 DUP(0Fh), 6 DUP(1), 22 DUP(2)
    attribute3 word 22 DUP(2), 11 DUP(1), 3 DUP(0Fh), 9 DUP(1), 19 DUP(2)
    attribute4 word 16 DUP(2), 3 DUP(1), 4 DUP(2), 24 DUP(1), 17 DUP(2)
    attribute5 word 2 DUP(2), 4 DUP(1), 6 DUP(2), 9 DUP(1), 3 DUP(2), 25 DUP(1), 11 DUP(2), 2 DUP(1), 2 DUP(2)
Earth ends


; Plane

PlaneWidth = 5

plane struct
    body1   byte    "^"
    body2   byte    "/_\"
    body3   byte    "/   \"
    body4   byte    "/     \"
    body5   byte    "/__[ ]__\"
    body6   byte    "//|||\\"
plane ends

lplane struct
    body1   byte    "/|"
    body2   byte    "(||"
    body3   byte    "/  \"
    body4   byte    "/    \"
    body5   byte    "/_|[___\"
    body6   byte    "\\\\\\\"
lplane ends

rplane struct
    body1   byte    "|\"
    body2   byte    "||)"
    body3   byte    "/  \"
    body4   byte    "/    \"
    body5   byte    "/___|]_\"
    body6   byte    "///////"
rplane ends

; Bullet
bullet struct
    body byte "|"
    bool byte 0
    XY coord <>
bullet ends

; Meteorite
meteor struct
    body1 byte "##"
    body2 byte "##"
    bool byte 0
    XY coord<0,1>
meteor ends

GameOver struct

    body1   byte    "   ____                         ___                   _ "
    body2   byte    "  / ___| __ _ _ __ ___   ___   / _ \__   _____ _ __  | |"
    body3   byte    " | |  _ / _` | '_ ` _ \ / _ \ | | | \ \ / / _ \ '__| | |"
    body4   byte    " | |_| | (_| | | | | | |  __/ | |_| |\ V /  __/ |    |_|"
    body5   byte    "  \____|\__,_|_| |_| |_|\___|  \___/  \_/ \___|_|    (_)"
    body6   byte    " __   __                 ____                         "
    body7   byte    " \ \ / /__  _   _ _ __  / ___|  ___ ___  _ __ ___   _ "
    body8   byte    "  \ V / _ \| | | | '__| \___ \ / __/ _ \| '__/ _ \ (_)"
    body9   byte    "   | | (_) | |_| | |     ___) | (_| (_) | | |  __/  _ "
    body10  byte    "   |_|\___/ \__,_|_|    |____/ \___\___/|_|  \___| (_)"
    body11  byte    "                                                      "
    bool byte 0
    XY coord<22,5>
GameOver ends

Lifes struct
    body1 byte " $$$$$$   $$$$$$ "
    body2 byte "$$$$$$$$ $$$$$$$$"
    body3 byte "$$$$$$$$$$$$$$$$$"
    body4 byte " $$$$$$$$$$$$$$$ "
    body5 byte "   $$$$$$$$$$$   "
    body6 byte "     $$$$$$$     "
    body7 byte "       $$$       "
    body8 byte "        $        "
    XY coord<64,18>
Lifes ends
.data

; Move Mark

BoolMoveLeft byte 0
BoolMoveRight byte 0


; Clear

;Eraser for still
eraser1 byte " "
eraser2 byte "   "
eraser3 byte "     "
eraser4 byte "       "
eraser5 byte "         "


;eraser for moving right or left
eraser6     byte "  "
eraser7     byte "   "
eraser8     byte "    "
eraser9     byte "      "
eraser10    byte "        "

;eraser for the tail
eraser11    byte "       "
eraser12 byte "                 "

; my plane

myplane plane <>
mylplane lplane <>
myrplane rplane <>
mytest BYTE '1'
pos coord <33,18>


temp COORD <>

; bullets
bullet1 bullet<>
bullet2 bullet<>
bullet3 bullet<>
bullet4 bullet<>
bullet5 bullet<>

; meteorite
meteor1 meteor<>
meteor2 meteor<>
meteor3 meteor<>
meteor4 meteor<>
BoolFlying byte 0

; explosion
explode1 ExplosionAnimation<>
explode2 ExplosionAnimation<>
explode3 ExplosionAnimation<>
; handle
outputHandle DWORD ?
check DWORD ?

; Background

; Score
score word 0
myscore byte "Score: ", 0

; Earth

MyEarth Earth<>

; Background Border
MyBackgroundBorder BackgroundBorder<>

; Speed Up Notification

SpeedUpNotification byte "!WARNING! THE METEORS ARE DROPPING FASTER THAN BEFORE!"
SpeedUpNotificationAttribute word 76 DUP (RED)
BoolSpeedUpNotification byte 0

; Background Plane
MyBackgroundPlane BackgroundPlane<>
; Starting
GameName EarthRanger<>
; Game over
Result GameOver<>
; Life
Heart Lifes<>
; Time
spawning_time word 0
NumberOfTwoSeconds word 0



.code
main PROC

    call clrscr

    ; get output handle
    invoke GetStdHandle, STD_OUTPUT_HANDLE
    mov outputHandle, eax
    call Intro
    call StartKey
    call SetUp
; game start
Game :
    call Background
    call InputKey
    call BulletFly
    call SpawnMeteor
    call MeteorFly
    call BulletHit
    call MeteorHitPlane
    call Life
    ;if hit by 3 times
    cmp Result.bool, 3
    je Game_over
    call Explosion
    jmp Game
Game_over:
    call Final
main ENDP

; process
StartKey proc uses eax
L1:
    mov eax, 50    ; delay for 1 second
    call Delay
    call ReadKey
    cmp al, '0'
    je Start
    jmp L1
Start:
    call clrscr
    ret
StartKey endp

InputKey proc uses eax
    mov eax, 20     ; delay for 0.02 seconds
    call Delay

    call ReadKey
    jz NoKey

    cmp al, 'a'
    je MoveLeft
    cmp al, 'd'
    je MoveRight
    cmp dx, VK_SPACE
    je Shoot
    cmp dx, VK_ESCAPE
    je quit

; Did not input any key
NoKey:

    call ClearPlaneLastPosition
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body1, lengthof myplane.body1, pos, addr check
    call GetTempXY
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body2, lengthof myplane.body2, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body3, lengthof myplane.body3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body4, lengthof myplane.body4, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body5, lengthof myplane.body5, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body6, lengthof myplane.body6, temp, addr check
    mov BoolMoveLeft, 0
    mov BoolMoveRight, 0

    ret

; input left key
MoveLeft:

    mov ax, pos.X
    dec ax
    cmp ax, PlaneWidth
    jb HitBorder

    ; clear previous

    call ClearPlaneLastPosition

    ; go to next position
    dec pos.X
    call GetTempXY
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body1, lengthof mylplane.body1, temp, addr check
    inc temp.Y
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body2, lengthof mylplane.body2, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body3, lengthof mylplane.body3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body4, lengthof mylplane.body4, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body5, lengthof mylplane.body5, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr mylplane.body6, lengthof mylplane.body6, temp, addr check
    ; change mark

    mov BoolMoveLeft, 1
    mov BoolMoveRight,0
    ret

; input right key
MoveRight:

    mov ax, pos.X
    inc ax
    cmp ax, RightBorder-PlaneWidth+1
    ja HitBorder

    ; clear previous

    call ClearPlaneLastPosition

    ; go to next position
    inc pos.X
    call GetTempXY
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body1, lengthof myrplane.body1, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body2, lengthof myrplane.body2, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body3, lengthof myrplane.body3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body4, lengthof myrplane.body4, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body5, lengthof myrplane.body5, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myrplane.body6, lengthof myrplane.body6, temp, addr check

    ; change mark

    mov BoolMoveLeft, 0
    mov BoolMoveRight,1

HitBorder:
    ret
; shooting

Shoot:
    cmp bullet1.bool, 1
    jne Shoot_Bullet1
    cmp bullet2.bool, 1
    jne Shoot_Bullet2
    cmp bullet3.bool, 1
    jne Shoot_Bullet3
    ;cmp BoolBullet4, 1
    ;jne Shoot_Bullet4
    ;cmp BoolBullet5, 1
    ;jne Shoot_Bullet5
    ret
Shoot_Bullet1:
    mov bullet1.bool, 1
    movzx eax, pos.X
    mov bullet1.XY.X, ax
    movzx eax, pos.Y
    mov bullet1.XY.Y, ax
    ret

Shoot_Bullet2:
    mov bullet2.bool, 1
    movzx eax, pos.X
    mov bullet2.XY.X, ax
    movzx eax, pos.Y
    mov bullet2.XY.Y, ax
    ret

Shoot_Bullet3:
    mov bullet3.bool, 1
    movzx eax, pos.X
    mov bullet3.XY.X, ax
    movzx eax, pos.Y
    mov bullet3.XY.Y, ax
    ret

Shoot_Bullet4:
    mov bullet4.bool, 1
    movzx eax, pos.X
    mov bullet4.XY.X, ax
    movzx eax, pos.Y
    mov bullet4.XY.Y, ax
    ret

Shoot_Bullet5:
    mov bullet5.bool, 1
    movzx eax, pos.X
    mov bullet5.XY.X, ax
    movzx eax, pos.Y
    mov bullet5.XY.Y, ax
    ret

; exit
quit:
    exit

InputKey endp

ClearPlaneLastPosition proc uses eax

    call GetTempXY
    ; check if last move is left
    cmp BoolMoveLeft, 1
    je LastMoveWasLeft
    ; check if last move is right
    cmp BoolMoveRight, 1
    je LastMoveWasRight

    ; if the plane stand still last second
DidNotMoveLastSecond:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser2, lengthof eraser2, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser3, lengthof eraser3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser4, lengthof eraser4, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser5, lengthof eraser5, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser11, lengthof eraser11, temp, addr check
    jmp finish

    ; if the plane move left last second

LastMoveWasLeft:
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser7, lengthof eraser7, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser8, lengthof eraser8, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser9, lengthof eraser9, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser10, lengthof eraser10, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser11, lengthof eraser11, temp, addr check
    jmp finish

    ; if the plane move right last second

LastMoveWasRight:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser7, lengthof eraser7, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser8, lengthof eraser8, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser9, lengthof eraser9, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser10, lengthof eraser10, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser11, lengthof eraser11, temp, addr check
    jmp finish

finish:
    ret
ClearPlaneLastPosition endp



BulletFly proc uses eax
CheckBullet1:
    cmp bullet1.bool, 1
    je Bullet1_Flying

CheckBullet2:
    cmp bullet2.bool, 1
    je Bullet2_Flying

CheckBullet3:
    cmp bullet3.bool, 1
    je Bullet3_Flying

CheckBullet4:
    cmp bullet4.bool, 1
    je Bullet4_Flying

CheckBullet5:
    cmp bullet5.bool, 1
    je Bullet5_Flying
    ret

; first bullet flying motion

Bullet1_Flying:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, bullet1.XY, addr check
    mov ax, bullet1.XY.Y
    dec ax
    cmp ax, 1
    jae Bullet1_NotYetTop
    ; Bullet 1 is at top
    mov bullet1.bool, 0
    jmp CheckBullet2

Bullet1_NotYetTop:
    dec bullet1.XY.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr bullet1.body, lengthof bullet1.body, bullet1.XY, addr check
    jmp CheckBullet2

; second bullet flying motion

Bullet2_Flying:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, bullet2.XY, addr check
    mov ax, bullet2.XY.Y
    dec ax
    cmp ax, 1
    jae Bullet2_NotYetTop
    ; Bullet 2 is at top
    mov bullet2.bool, 0
    jmp CheckBullet3

Bullet2_NotYetTop:
    dec bullet2.XY.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr bullet2.body, lengthof bullet2.body, bullet2.XY, addr check
    jmp CheckBullet3

Bullet3_Flying:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, bullet3.XY, addr check
    mov ax, bullet3.XY.Y
    dec ax
    cmp ax, 1
    jae Bullet3_NotYetTop
    ; Bullet 3 is at top
    mov bullet3.bool, 0
    jmp CheckBullet4

Bullet3_NotYetTop:
    dec bullet3.XY.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr bullet3.body, lengthof bullet3.body, bullet3.XY, addr check
    jmp CheckBullet4

Bullet4_Flying:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, bullet4.XY, addr check
    mov ax, bullet4.XY.Y
    dec ax
    cmp ax, 1
    jae Bullet4_NotYetTop
    mov bullet4.bool, 0
    jmp CheckBullet5

Bullet4_NotYetTop:
    dec bullet4.XY.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr bullet4.body, lengthof bullet4.body, bullet4.XY, addr check
    jmp CheckBullet5

Bullet5_Flying:
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, bullet5.XY, addr check
    mov ax, bullet5.XY.Y
    dec ax
    cmp ax , 1
    jae Bullet5_NotYetTop
    mov bullet5.bool, 0
    ret

Bullet5_NotYetTop:
    dec bullet5.XY.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr bullet5.body, lengthof bullet5.body, bullet5.XY, addr check
    ret

BulletFly endp

; spawning meteor

SpawnMeteor proc uses eax
    cmp meteor1.bool, 1
    jne m1
    ret
m1:
    mov eax, 53
    call RandomRange
    add ax, 5
    mov meteor1.XY.X, ax
    mov meteor1.XY.Y, -1
    mov meteor1.bool, 1
    ret
SpawnMeteor endp

; meteor flying

MeteorFly proc uses eax

CheckFlyingTime:
    call TimeToFly
    cmp BoolFlying, 1
    je Fly
    ret

Fly:
CheckMeteor1:
    cmp meteor1.bool, 1
    je m1Flying
    ret

m1Flying:
    movzx eax, meteor1.XY.X
    mov temp.X, ax
    movzx eax, meteor1.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    mov ax, meteor1.XY.Y
    inc ax
    cmp ax, 23
    jbe NotYetBottom
    mov meteor1.bool, 0
    inc result.bool
CheckExplosion1:
    cmp explode1.mode, 0
    je explosion11
    ret

explosion11:
    mov explode1.mode, 1
    movzx eax, meteor1.XY.X
    add eax, 2
    mov explode1.XY.X, ax
    movzx eax, meteor1.XY.Y
    mov explode1.XY.Y, ax
    ret

NotYetBottom:
    inc meteor1.XY.Y
    movzx eax, meteor1.XY.X
    mov temp.X, ax
    movzx eax, meteor1.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr meteor1.body1, lengthof meteor1.body1, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr meteor1.body2, lengthof meteor1.body2, temp, addr check
    ret
MeteorFly endp

; hit

BulletHit proc uses eax ebx edx

CheckMeteor1Flying:
    cmp meteor1.bool, 1
    je Meteor1IsFlying

    ret
Meteor1IsFlying:

check_bullet1:
    mov ax, bullet1.XY.Y
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp ax, bx
    je SameAltitude1
    cmp ax, dx
    je SameAltitude1
    jmp check_bullet2

SameAltitude1:
    mov ax, bullet1.XY.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
    cmp ax, bx
    je SameXY1
    cmp ax, dx
    je SameXY1
    jmp check_bullet2

SameXY1:
    inc score
    mov bullet1.bool, 0
    mov meteor1.bool, 0
    movzx eax, meteor1.XY.X
    mov temp.X, ax
    movzx eax, meteor1.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check

CheckExplosion1:
    cmp explode1.mode, 0
    je explosion11
    ret

explosion11:
    mov explode1.mode, 1
    movzx eax, bullet1.XY.X
    mov explode1.XY.X, ax
    movzx eax, bullet1.XY.Y
    mov explode1.XY.Y, ax
    ret

check_bullet2:
    mov ax, bullet2.XY.Y
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp ax, bx
    je SameAltitude2
    cmp ax, dx
    je SameAltitude2
    jmp check_bullet3

SameAltitude2:
    mov ax, bullet2.XY.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
    cmp ax, bx
    je SameXY2
    cmp ax, dx
    je SameXY2
    jmp check_bullet3

SameXY2:
    inc score
    mov bullet2.bool, 0
    mov meteor1.bool, 0
    movzx eax, meteor1.XY.X
    mov temp.X, ax
    movzx eax, meteor1.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check

CheckExplosion2:
    cmp explode1.mode, 0
    je explosion12
    ret

explosion12:
    mov explode1.mode, 1
    movzx eax, bullet2.XY.X
    mov explode1.XY.X, ax
    movzx eax, bullet2.XY.Y
    mov explode1.XY.Y, ax
    ret


check_bullet3:

    mov ax, bullet3.XY.Y
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp ax, bx
    je SameAltitude3
    cmp ax, dx
    je SameAltitude3
    ret
SameAltitude3:
    mov ax, bullet3.XY.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
    cmp ax, bx
    je SameXY3
    cmp ax, dx
    je SameXY3
    ret
SameXY3:
    inc score
    mov bullet3.bool, 0
    mov meteor1.bool, 0
    movzx eax, meteor1.XY.X
    mov temp.X, ax
    movzx eax, meteor1.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp, addr check

CheckExplosion3:
    cmp explode1.mode, 0
    je explosion13
    ret
explosion13:
    mov explode1.mode, 1
    movzx eax, bullet3.XY.X
    mov explode1.XY.X, ax
    movzx eax, bullet3.XY.Y
    mov explode1.XY.Y, ax
    ret

; check bullet4

; check bullet5
    ret
BulletHit endp

MeteorHitPlane proc uses eax ebx edx

; copy plane XY into temp
    movzx eax, pos.X
    mov temp.X, ax
    movzx eax, pos.Y
    mov temp.Y, ax

; The plane move left
    cmp BoolMoveLeft, 1
    je MoveLeft


; The plane move right
    cmp BoolMoveRight, 1
    je MoveRight

; The plane stand still
StandStill:
    call CheckMeteorHitWhenStandStill

MoveRight:
    call CheckMeteorHitWhenMoveRight

MoveLeft:
    call CheckMeteorHitWhenMoveLeft

    ret
MeteorHitPlane endp

CheckMeteorHitWhenStandStill proc uses eax ebx edx
CheckMeteor1Flying:
    cmp meteor1.bool, 1
    je Meteor1IsFlying
    ret
Meteor1IsFlying:
;compare with tip of the plane
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp temp.Y, bx
    je SameAltitudeWithTip
    cmp temp.Y, dx
    je SameAltitudeWithTip
;compare with one block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide1
    cmp temp.Y, dx
    je SameAltitudeWithSide1

; compare with two block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide2
    cmp temp.Y, dx
    je SameAltitudeWithSide2

; compare with three block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide3
    cmp temp.Y, dx
    je SameAltitudeWithSide3

    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide4
    cmp temp.Y, dx
    je SameAltitudeWithSide4

DidNotHitPlane:
    ret

;If the meteor is in the same altitude with the tip of the plane
SameAltitudeWithTip:
    mov ax, temp.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
    cmp ax, bx
    je GotHit
    cmp ax, dx
    je GotHit
    ret


;If the meteor is in the same altitude with one block left/right of the plane
SameAltitudeWithSide1:
; right 1
    inc temp.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; left 1
    sub temp.X, 2
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with two block left/right of of the plane
SameAltitudeWithSide2:
; right 2
    add temp.X,2
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; left 2
    sub temp.X, 4
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with three block left/right of the plane
SameAltitudeWithSide3:
    ; right 3
    add temp.X, 3
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; left 3
    sub temp.X, 6
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

SameAltitudeWithSide4:
    ; right 4
    add temp.X, 4
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; left 4
    sub temp.X, 8
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

    ret
GotHit:
    add Result.bool, 1
    invoke HitByMeteor, temp
    ret

CheckMeteorHitWhenStandStill endp

; The plane move left
CheckMeteorHitWhenMoveRight proc uses eax ebx edx

CheckMeteor1Flying:
    cmp meteor1.bool, 1
    je Meteor1IsFlying
    ret

Meteor1IsFlying:
;compare with tip of the plane
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp temp.Y, bx
    je SameAltitudeWithTip
    cmp temp.Y, dx
    je SameAltitudeWithTip
;compare with one block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide1
    cmp temp.Y, dx
    je SameAltitudeWithSide1

; compare with two block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide2
    cmp temp.Y, dx
    je SameAltitudeWithSide2

; compare with three block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide3
    cmp temp.Y, dx
    je SameAltitudeWithSide3

    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide4
    cmp temp.Y, dx
    je SameAltitudeWithSide4

DidNotHitPlane:
    ret

;If the meteor is in the same altitude with the tip of the plane
SameAltitudeWithTip:
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with tip
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

    inc temp.X
; compare with right1
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with one block left/right of the plane
SameAltitudeWithSide1:
; right 1
    inc temp.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right 1
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

; right 2
    inc temp.X
; compare with right 2
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

; body
    sub temp.X, 2
; compare with body
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with two block left/right of of the plane
SameAltitudeWithSide2:
; right 3
    add temp.X, 3
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; body
    sub temp.X, 3
; compare with body
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret


;If the meteor is in the same altitude with three block left/right of the plane
SameAltitudeWithSide3:
    ; right 4
    add temp.X, 4
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; rleft 1
    sub temp.X, 5
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

SameAltitudeWithSide4:
    ; left 2
    sub temp.X, 2
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; right 5
    add temp.X, 7
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

    ret

GotHit:
    invoke HitByMeteor, temp
    add Result.bool, 1
    ret

CheckMeteorHitWhenMoveRight endp




CheckMeteorHitWhenMoveLeft proc uses eax ebx edx

CheckMeteor1Flying:
    cmp meteor1.bool, 1
    je Meteor1IsFlying
    ret

Meteor1IsFlying:
;compare with tip of the plane
    mov bx, meteor1.XY.Y
    mov dx, bx
    inc bx
    cmp temp.Y, bx
    je SameAltitudeWithTip
    cmp temp.Y, dx
    je SameAltitudeWithTip
;compare with one block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide1
    cmp temp.Y, dx
    je SameAltitudeWithSide1

; compare with two block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide2
    cmp temp.Y, dx
    je SameAltitudeWithSide2

; compare with three block left/right of the plane
    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide3
    cmp temp.Y, dx
    je SameAltitudeWithSide3

    inc temp.Y
    cmp temp.Y, bx
    je SameAltitudeWithSide4
    cmp temp.Y, dx
    je SameAltitudeWithSide4

DidNotHitPlane:
    ret

;If the meteor is in the same altitude with the tip of the plane
SameAltitudeWithTip:
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with tip
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

    dec temp.X
; compare with left 1
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with one block left/right of the plane
SameAltitudeWithSide1:
; left 1
    dec temp.X
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with left 1
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

; left 2
    dec temp.X
; compare with left 2
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

; body
    add temp.X, 2
; compare with body
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

;If the meteor is in the same altitude with two block left/right of of the plane
SameAltitudeWithSide2:
; left 3
    sub temp.X, 3
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; body
    add temp.X, 3
; compare with body
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret


;If the meteor is in the same altitude with three block left/right of the plane
SameAltitudeWithSide3:
    ; left 4
    sub temp.X, 4
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; right 1
    add temp.X, 5
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
    ret

SameAltitudeWithSide4:
    ; right 2
    add temp.X, 2
    mov bx, meteor1.XY.X
    mov dx, bx
    inc dx
; compare with right
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit
; left 5
    sub temp.X, 7
; compare with left
    cmp temp.X, bx
    je GotHit
    cmp temp.X, dx
    je GotHit

    ret

GotHit:
    add Result.bool, 1
    invoke HitByMeteor, temp
    ret
CheckMeteorHitWhenMoveLeft endp


; explosion

Explosion proc

CheckExplosion1:
    cmp explode1.mode, 0
    jne Exploding
    ret
Exploding:
    movzx eax, explode1.XY.X
    mov temp.X, ax
    movzx eax, explode1.XY.Y
    mov temp.Y, ax
    cmp explode1.mode, 1
    je Ex1M1
    cmp explode1.mode, 2
    je Ex1M2
    cmp explode1.mode, 3
    je Ex1M3
    cmp explode1.mode, 4
    je Ex1M4
    ret
Ex1M1:
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body1, lengthof explode1.body1, temp, addr check
    inc explode1.mode
    ret
Ex1M2:
    ; clear last explosion
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, temp, addr check

    dec temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body1, lengthof explode1.body1, temp, addr check
    inc temp.Y
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body2, lengthof explode1.body2, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body1, lengthof explode1.body1, temp, addr check
    inc explode1.mode
    ret
Ex1M3:
    ; clear last explosion
    dec temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, temp, addr check
    inc temp.Y
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser7, lengthof eraser7, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser1, lengthof eraser1, temp, addr check

    sub temp.Y, 2
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body3, lengthof explode1.body3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body4, lengthof explode1.body4, temp, addr check
    inc temp.Y
    inc temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr explode1.body3, lengthof explode1.body3, temp, addr check
    inc explode1.mode
    ret
Ex1M4:
    ; clear last explosion
    dec temp.Y
    dec temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser7, lengthof eraser7, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser9, lengthof eraser9, temp, addr check
    inc temp.Y
    inc temp.X
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser7, lengthof eraser7, temp, addr check
    mov explode1.mode, 0
    ret

    ret
Explosion endp



SetUp proc uses eax

    ; print plane
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body1, lengthof myplane.body1, pos, addr check
    call GetTempXY
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body2, lengthof myplane.body2, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body3, lengthof myplane.body3, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body4, lengthof myplane.body4, temp, addr check
    dec temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body5, lengthof myplane.body5, temp, addr check
    inc temp.X
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr myplane.body6, lengthof myplane.body6, temp, addr check

    ret

SetUp endp

Background proc uses eax esi ecx
    local WarningXY : coord
    local BorderXY : coord
    local PlaneXY : coord
    local EarthXY : coord

    mov BorderXY.X, 64
    mov BorderXY.Y, 0
    ; Print Background Border
    invoke WriteConsoleOutputCharacter, outputHandle, addr MyBackgroundBorder.body1, lengthof MyBackgroundBorder.body1, BorderXY, addr check
    inc BorderXY.Y
    mov ecx, 13
PrintBorder:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, addr MyBackgroundBorder.body2, lengthof MyBackgroundBorder.body2, BorderXY, addr check
    inc BorderXY.Y
    pop ecx
    loop PrintBorder
    invoke WriteConsoleOutputCharacter, outputHandle, addr MyBackgroundBorder.body3, lengthof MyBackgroundBorder.body1, BorderXY, addr check


    ; Print Earth
    mov EarthXY.X, 0
    mov EarthXY.Y, 25
    mov ecx, 5
    mov esi, offset MyEarth.body1
    mov edi, offset MyEarth.attribute1
PrintEarth:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Earth.body1, EarthXY, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, edi, lengthof Earth.body1, EarthXY, addr check
    inc EarthXY.Y
    add esi, SIZEOF Earth.body1
    add edi, SIZEOF Earth.attribute1
    pop ecx
    loop PrintEarth

    ; Print Background Plane
    mov PlaneXY.X, 72
    mov PlaneXY.Y, 3
    mov esi, OFFSET MyBackgroundPlane.body0
    mov ecx, 8
PrintPlane:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, MyBackgroundPlane.PlaneLength, PlaneXY, addr check
    inc PlaneXY.Y
    add esi, MyBackgroundPlane.PlaneLength
    pop ecx
    loop PrintPlane

; Print Score

    mov dh, 12
    mov dl, 108
    call GoToXY
    mov edx, offset myscore
    call WriteString
    movzx eax, score
    call WriteDec

; Print Speed Up Notification
    cmp BoolSpeedUpNotification, 1
    jne Finish
    cmp spawning_time, 30
    jb Finish
    mov WarningXY.X, 65
    mov WarningXY.Y, 13
    invoke WriteConsoleOutputCharacter, outputHandle, addr SpeedUpNotification, lengthof SpeedUpNotification, WarningXY, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr SpeedUpNotificationAttribute, lengthof SpeedUpNotification, WarningXY, addr check

Finish:
    ret

Background endp

Intro proc
    ; print earthranger
    movzx eax, GameName.XY.X
    mov temp.X, ax
    movzx eax, GameName.XY.Y
    mov temp.Y, ax
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body1, lengthof GameName.body1, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute1, lengthof GameName.body1, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body2, lengthof GameName.body2, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute1, lengthof GameName.body2, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body3, lengthof GameName.body3, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute2, lengthof GameName.body3, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body4, lengthof GameName.body4, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute3, lengthof GameName.body4, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body5, lengthof GameName.body5, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute4, lengthof GameName.body5, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body6, lengthof GameName.body6, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute5, lengthof GameName.body4, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body7, lengthof GameName.body7, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute5, lengthof GameName.body5, temp, addr check
    sub temp.X, 4
    add temp.Y, 5
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body8, lengthof GameName.body8, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body8, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body9, lengthof GameName.body9, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body9, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body10, lengthof GameName.body10, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body10, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body11, lengthof GameName.body11, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body11, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body12, lengthof GameName.body12, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body12, temp, addr check
    inc temp.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr GameName.body13, lengthof GameName.body13, temp, addr check
    invoke WriteConsoleOutputAttribute, outputHandle, addr GameName.attribute6, lengthof GameName.body13, temp, addr check

    ret

Intro endp
; get x and y coordinate into temp

GetTempXY proc uses eax
    movzx eax, pos.X
    mov temp.X, ax
    movzx eax, pos.Y
    mov temp.Y, ax
    ret
GetTempXY endp



TimeToFly proc uses eax ebx

    inc spawning_time
    cmp NumberOfTwoSeconds, 15
    ja WarningNotification
    mov BoolSpeedUpNotification, 0
CheckSpeedUpTime :
    cmp NumberOfTwoSeconds, 20
    ja Fast

Slow:
    mov ax, spawning_time
    mov bl, 10
    div bl
    cmp ah, 0
    je DivideByFour
    mov BoolFlying, 0

CheckTwoSeconds:
    cmp spawning_time, 60
    je TwoSeconds
    ret

WarningNotification:
    mov BoolSpeedUpNotification, 1
    jmp CheckSpeedUpTime

Fast:
    mov ax, spawning_time
    mov bl, 5
    div bl
    cmp ah,0
    je DivideByThree
    mov BoolFlying, 0
    jmp CheckTwoSeconds

TwoSeconds:
    inc NumberOfTwoSeconds
    mov spawning_time, 0
    jmp CheckOneMinute

CheckOneMinute:
    cmp NumberOfTwoSeconds, 30
    jne Finish
    mov NumberOfTwoSeconds, 0
Finish:
    ret

DivideByFour:
    mov BoolFlying, 1
    jmp CheckTwoSeconds

DivideByThree:
    mov BoolFlying, 1
    jmp CheckTwoSeconds

TimeToFly endp

HitByMeteor proc uses eax, temp_coord:coord

    mov meteor1.bool, 0
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp_coord, addr check
    inc temp_coord.Y
    invoke WriteConsoleOutputCharacter, outputHandle, addr eraser6, lengthof eraser6, temp_coord, addr check
    dec temp_coord.Y
    jmp CheckExplosion
    ret

CheckExplosion:
    cmp explode1.mode, 0
    je explosion1
    ret
explosion1:
    mov explode1.mode, 1
    movzx eax, temp_coord.X
    mov explode1.XY.X, ax
    movzx eax, temp_coord.Y
    mov explode1.XY.Y, ax
    ret

HitByMeteor endp

CopyCoordFrom proc uses eax, temp1 : coord, temp2 : coord
    mov eax, 0
    mov ax, temp1.X
    mov temp2.X, ax
    mov ax, temp1.Y
    mov temp2.Y, ax
    ret
CopyCoordFrom endp

Final proc uses eax
    ; print Game Over
    call clrscr
    movzx eax, Result.XY.X
    mov temp.X, ax
    movzx eax, Result.XY.Y
    mov temp.Y, ax

    mov ecx, 5
    mov esi, offset Result.body1
PrintG:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Result.body1, temp, addr check
    inc temp.Y
    add esi, sizeof result.body1
    pop ecx
    loop Printg

    sub temp.X, 4
    add temp.Y, 6
    mov ecx, 6
    mov esi, offset Result.body6
PrintS:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Result.body6, temp, addr check
    inc temp.Y
    add esi, sizeof result.body6
    pop ecx
    loop PrintS

    ret
Final endp

Life proc uses eax
    movzx eax, Heart.XY.X
    mov temp.X, ax
    movzx eax, Heart.XY.Y
    mov temp.Y, ax
    cmp Result.bool, 1
    ja Life1
    je Life2
    jb Life3
;3 life remaining
Life3:
    mov ecx, 8
    mov esi, offset Heart.body1
print3l:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    add temp.X, 18
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    add temp.X, 18
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    sub temp.X, 36
    inc temp.Y
    add esi, sizeof Heart.body1
    pop ecx
    loop print3l

    sub temp.Y, 8
    jmp EndofJudge
;2 life remaining
Life2:
    mov ecx, 8
    mov esi, offset Heart.body1
print2l:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    add temp.X, 18
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    sub temp.X, 18
    inc temp.Y
    add esi, sizeof Heart.body1
    pop ecx
    loop print2l

    sub temp.Y, 8
    add temp.X, 36
    mov ecx, 8
    mov esi, offset eraser12
erase1l:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof eraser12, temp, addr check
    inc temp.Y
    pop ecx
    loop erase1l
    jmp EndofJudge
;1 life remaining
Life1:
    mov ecx, 8
    mov esi, offset heart.body1
print1l:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof Heart.body1, temp, addr check
    inc temp.Y
    add esi, sizeof heart.body1
    pop ecx
    loop print1l
    sub temp.Y, 8
    add temp.X, 18
    mov ecx, 8
    mov esi, offset eraser12
erase2l:
    push ecx
    invoke WriteConsoleOutputCharacter, outputHandle, esi, lengthof eraser12, temp, addr check
    inc temp.Y
    pop ecx
    loop erase2l
    jmp EndofJudge
EndOfJudge:
    ret
Life endp

END main
